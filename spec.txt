-*- mode: outline -*-

* fetch(url)

Checks the cache for url.
  - If it exists, returns it
  - Else, starts a server_fetch() in background
    - Returns stub data immediately
    - When server_fetch() completes:
      - update_cache()
      - and re-render the page

* server_fetch(url, callback)
Grabs json from the server, runs callback on it when finished

* update_cache(object)
** Purpose
Recurses through the object and folds it into the cache.

** Code
If object has url field:
  If cache has no object there
    cache[url] = object
  Else
    Mutate cache[url] so it = object

Recurse:
  If object is array, on each element in array
  If object is hash, on each value in hash

  After each recursion, update element to the value returned in
  recursion.

Return cache[url] || object

** Questions
What if someone uses an array with a url field?  Is that possible?
Right now I'm assuming that if there's a URL field that this is a
hash.

** Future Optimizations
Over time, the cache will grow unbounded unless we start deleting
things.

We should keep track of the most recent observation per url, and
periodically sweep through and delete the oldest ones from the cache.

* save(object, ...)
 - update_cache(object, ...)
 - server_save(object, ...)
 - return cache[object.url]
* server_save(object, ...)
?? 

* Partially-Loaded Data
** Requirements
*** Views
- Need to be able to specify which parts of the data they depend upon
- Need to be able to use a loaded subset, while waiting for a larger
  set to load

*** Cache
- Incorporate new subsets of data as they come over the wire
- Store a union of all subsets at all times

*** Server
- Need to be able to return partial data
- Needs to specify which parts of the data it's returning

** Subset URLs
Some views will need only partial data to be loaded.  The views will
communicate the subset of the data they depend upon by adding a
parameter to the REST key:

    fetch("/proposal/34?subset=summary")

If a program only ever uses a single type of subset, it can skip the
"=summary" part, and just say "?subset":

    fetch("/proposal/34?subset")

Next, we'll want to mark this information in the cache, so that when a
new view needs the data, it knows whether it can use the cached
version, or if it needs to get more data from the server.  So we'll
record:

    key = "/proposal/34?subset"

Or, if there are multiple subsets used in your app, then you specify a
particular one with "?subset=<label>":

   key = "/proposal/34?subset=summary"

If multiple subsets have been loaded, the cache will keep track of
them with:

   key = "/proposal/34?subset=summary,mobile"

Sometimes we'll put objects in the cache that are totally empty -- so
that other parts of the application get an object that will be filled
in later.  We will specify empty objects with "?subset=empty":

   key = "/proposal/34?subset=summary"

And the default indicates that an entire object has been loaded:

   key = "/proposal/34"

** is_loaded(obj, <optional> subset)
This function will check the object's key to see if it has the subset
loaded yet.  Returns false if not.

** Storing it 
The cache wants to maintain a single object for all subsets.  So it
inserts objects into the cache by ignoring the '?__' part:

    cache['/proposal'] ==> {url: '/proposal?subset=summary' ...}

** Rendering loading indicators
This will be automated in the future.  But for now, write an if
statement inside a component's render() function like this:

  render: function () {
             if (this.is_loaded('subset')) {
                 ... render normal stuff ...
             } else {
                 ... render loading indicator ...
             }
          }

* Future Optimizations & Improvements
** LocalStorage
